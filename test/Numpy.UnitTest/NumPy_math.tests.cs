// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_mathTest : BaseTestCase
    {
        [TestMethod]
        public void unwrapTest()
        {
            // >>> phase = np.linspace(0, np.pi, num=5)
            // >>> phase[3:] += np.pi
            // >>> phase
            // array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])
            // >>> np.unwrap(phase)
            // array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  phase = np.linspace(0, np.pi, num=5);
            given=  phase[3:] += np.pi;
            given=  phase;
            expected=
                "array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])";
            Assert.AreEqual(expected, given.repr);
            given=  np.unwrap(phase);
            expected=
                "array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void aroundTest()
        {
            // >>> np.around([0.37, 1.64])
            // array([ 0.,  2.])
            // >>> np.around([0.37, 1.64], decimals=1)
            // array([ 0.4,  1.6])
            // >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
            // array([ 0.,  2.,  2.,  4.,  4.])
            // >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
            // array([ 1,  2,  3, 11])
            // >>> np.around([1,2,3,11], decimals=-1)
            // array([ 0,  0,  0, 10])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.around([0.37, 1.64]);
            expected=
                "array([ 0.,  2.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.around([0.37, 1.64], decimals=1);
            expected=
                "array([ 0.4,  1.6])";
            Assert.AreEqual(expected, given.repr);
            given=  np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value;
            expected=
                "array([ 0.,  2.,  2.,  4.,  4.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.around([1,2,3,11], decimals=1) # ndarray of ints is returned;
            expected=
                "array([ 1,  2,  3, 11])";
            Assert.AreEqual(expected, given.repr);
            given=  np.around([1,2,3,11], decimals=-1);
            expected=
                "array([ 0,  0,  0, 10])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void fixTest()
        {
            // >>> np.fix(3.14)
            // 3.0
            // >>> np.fix(3)
            // 3.0
            // >>> np.fix([2.1, 2.9, -2.1, -2.9])
            // array([ 2.,  2., -2., -2.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.fix(3.14);
            expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.fix(3);
            expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.fix([2.1, 2.9, -2.1, -2.9]);
            expected=
                "array([ 2.,  2., -2., -2.])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }

        [TestMethod]
        public void prodTest()
        {
            // By default, calculate the product of all elements:

            // >>> np.prod([1.,2.])
            // 2.0

            Assert.AreEqual(2.0, np.prod(new[] { 1.0, 2.0 }).asscalar<double>());

            // Even when the input array is two-dimensional:
            
            // >>> np.prod([[1.,2.],[3.,4.]])
            // 24.0

            Assert.AreEqual(24.0, (double)np.prod(new[,] { { 1.0, 2.0 }, { 3.0, 4.0 } }));

            // But we can also specify the axis over which to multiply:
            
            // >>> np.prod([[1.,2.],[3.,4.]], axis=1)
            // array([  2.,  12.])

            var given= np.prod(new[,] { { 1.0, 2.0 }, { 3.0, 4.0 } }, axis:new []{1});
            var expected= "array([ 2., 12.])";
            Assert.AreEqual(expected, given.repr);

            // If the type of x is unsigned, then the output type is
            // the unsigned platform integer:
            
            // >>> x = np.array([1, 2, 3], dtype=np.uint8)
            // >>> np.prod(x).dtype == np.uint
            // True
            
            var  x = np.array(new byte[]{1, 2, 3}, dtype:np.uint8);
            Assert.AreEqual( np.@uint, np.prod(x).dtype);

            // If x is of a signed integer type, then the output type
            // is the default platform integer:

            x = np.array(new byte[] { 1, 2, 3 }, dtype: np.int8);
            Assert.AreEqual(np.int_, np.prod(x).dtype);

            // You can also start the product with a value other than one:

            // >>> np.prod([1, 2], initial=5)
            // 10

            Assert.AreEqual(10, (int)np.prod(new[] { 1, 2 }, initial: 5));
        }

        [TestMethod]
        public void sumTest()
        {
            // >>> np.sum([0.5, 1.5])
            // 2.0
            // >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
            // 1
            // >>> np.sum([[0, 1], [0, 5]])
            // 6
            // >>> np.sum([[0, 1], [0, 5]], axis=0)
            // array([0, 6])
            // >>> np.sum([[0, 1], [0, 5]], axis=1)
            // array([1, 5])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.sum([0.5, 1.5]);
            expected=
                "2.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32);
            expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            given=  np.sum([[0, 1], [0, 5]]);
            expected=
                "6";
            Assert.AreEqual(expected, given.repr);
            given=  np.sum([[0, 1], [0, 5]], axis=0);
            expected=
                "array([0, 6])";
            Assert.AreEqual(expected, given.repr);
            given=  np.sum([[0, 1], [0, 5]], axis=1);
            expected=
                "array([1, 5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // If the accumulator is too small, overflow occurs:
            
            // >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
            // -128
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.ones(128, dtype=np.int8).sum(dtype=np.int8);
            expected=
                "-128";
            Assert.AreEqual(expected, given.repr);
            #endif
            // You can also start the sum with a value other than zero:
            
            // >>> np.sum([10], initial=5)
            // 15
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.sum([10], initial=5);
            expected=
                "15";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void nanprodTest()
        {
            // >>> np.nanprod(1)
            // 1
            // >>> np.nanprod([1])
            // 1
            // >>> np.nanprod([1, np.nan])
            // 1.0
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nanprod(a)
            // 6.0
            // >>> np.nanprod(a, axis=0)
            // array([ 3.,  2.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.nanprod(1);
            expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            given=  np.nanprod([1]);
            expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            given=  np.nanprod([1, np.nan]);
            expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.array([[1, 2], [3, np.nan]]);
            given=  np.nanprod(a);
            expected=
                "6.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.nanprod(a, axis=0);
            expected=
                "array([ 3.,  2.])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void nansumTest()
        {
            // >>> np.nansum(1)
            // 1
            // >>> np.nansum([1])
            // 1
            // >>> np.nansum([1, np.nan])
            // 1.0
            // >>> a = np.array([[1, 1], [1, np.nan]])
            // >>> np.nansum(a)
            // 3.0
            // >>> np.nansum(a, axis=0)
            // array([ 2.,  1.])
            // >>> np.nansum([1, np.nan, np.inf])
            // inf
            // >>> np.nansum([1, np.nan, np.NINF])
            // -inf
            // >>> np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
            // nan
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.nansum(1);
            expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum([1]);
            expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum([1, np.nan]);
            expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.array([[1, 1], [1, np.nan]]);
            given=  np.nansum(a);
            expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum(a, axis=0);
            expected=
                "array([ 2.,  1.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum([1, np.nan, np.inf]);
            expected=
                "inf";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum([1, np.nan, np.NINF]);
            expected=
                "-inf";
            Assert.AreEqual(expected, given.repr);
            given=  np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present;
            expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void cumprodTest()
        {
            // >>> a = np.array([1,2,3])
            // >>> np.cumprod(a) # intermediate results 1, 1*2
            // ...               # total product 1*2*3 = 6
            // array([1, 2, 6])
            // >>> a = np.array([[1, 2, 3], [4, 5, 6]])
            // >>> np.cumprod(a, dtype=float) # specify type of output
            // array([   1.,    2.,    6.,   24.,  120.,  720.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  a = np.array([1,2,3]);
            given=  np.cumprod(a) # intermediate results 1, 1*2;
            expected=
                "...               # total product 1*2*3 = 6\n" +
                "array([1, 2, 6])";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.array([[1, 2, 3], [4, 5, 6]]);
            given=  np.cumprod(a, dtype=float) # specify type of output;
            expected=
                "array([   1.,    2.,    6.,   24.,  120.,  720.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The cumulative product for each column (i.e., over the rows) of a:
            
            // >>> np.cumprod(a, axis=0)
            // array([[ 1,  2,  3],
            //        [ 4, 10, 18]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.cumprod(a, axis=0);
            expected=
                "array([[ 1,  2,  3],\n" +
                "       [ 4, 10, 18]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The cumulative product for each row (i.e. over the columns) of a:
            
            // >>> np.cumprod(a,axis=1)
            // array([[  1,   2,   6],
            //        [  4,  20, 120]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.cumprod(a,axis=1);
            expected=
                "array([[  1,   2,   6],\n" +
                "       [  4,  20, 120]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void cumsumTest()
        {
            // >>> a = np.array([[1,2,3], [4,5,6]])
            // >>> a
            // array([[1, 2, 3],
            //        [4, 5, 6]])
            // >>> np.cumsum(a)
            // array([ 1,  3,  6, 10, 15, 21])
            // >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
            // array([  1.,   3.,   6.,  10.,  15.,  21.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  a = np.array([[1,2,3], [4,5,6]]);
            given=  a;
            expected=
                "array([[1, 2, 3],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.cumsum(a);
            expected=
                "array([ 1,  3,  6, 10, 15, 21])";
            Assert.AreEqual(expected, given.repr);
            given=  np.cumsum(a, dtype=float)     # specifies type of output value(s);
            expected=
                "array([  1.,   3.,   6.,  10.,  15.,  21.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
            // array([[1, 2, 3],
            //        [5, 7, 9]])
            // >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
            // array([[ 1,  3,  6],
            //        [ 4,  9, 15]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns;
            expected=
                "array([[1, 2, 3],\n" +
                "       [5, 7, 9]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows;
            expected=
                "array([[ 1,  3,  6],\n" +
                "       [ 4,  9, 15]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void nancumprodTest()
        {
            // >>> np.nancumprod(1)
            // array([1])
            // >>> np.nancumprod([1])
            // array([1])
            // >>> np.nancumprod([1, np.nan])
            // array([ 1.,  1.])
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nancumprod(a)
            // array([ 1.,  2.,  6.,  6.])
            // >>> np.nancumprod(a, axis=0)
            // array([[ 1.,  2.],
            //        [ 3.,  2.]])
            // >>> np.nancumprod(a, axis=1)
            // array([[ 1.,  2.],
            //        [ 3.,  3.]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.nancumprod(1);
            expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumprod([1]);
            expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumprod([1, np.nan]);
            expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.array([[1, 2], [3, np.nan]]);
            given=  np.nancumprod(a);
            expected=
                "array([ 1.,  2.,  6.,  6.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumprod(a, axis=0);
            expected=
                "array([[ 1.,  2.],\n" +
                "       [ 3.,  2.]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumprod(a, axis=1);
            expected=
                "array([[ 1.,  2.],\n" +
                "       [ 3.,  3.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void nancumsumTest()
        {
            // >>> np.nancumsum(1)
            // array([1])
            // >>> np.nancumsum([1])
            // array([1])
            // >>> np.nancumsum([1, np.nan])
            // array([ 1.,  1.])
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nancumsum(a)
            // array([ 1.,  3.,  6.,  6.])
            // >>> np.nancumsum(a, axis=0)
            // array([[ 1.,  2.],
            //        [ 4.,  2.]])
            // >>> np.nancumsum(a, axis=1)
            // array([[ 1.,  3.],
            //        [ 3.,  3.]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.nancumsum(1);
            expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumsum([1]);
            expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumsum([1, np.nan]);
            expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.array([[1, 2], [3, np.nan]]);
            given=  np.nancumsum(a);
            expected=
                "array([ 1.,  3.,  6.,  6.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumsum(a, axis=0);
            expected=
                "array([[ 1.,  2.],\n" +
                "       [ 4.,  2.]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.nancumsum(a, axis=1);
            expected=
                "array([[ 1.,  3.],\n" +
                "       [ 3.,  3.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void diffTest()
        {
            // >>> x = np.array([1, 2, 4, 7, 0])
            // >>> np.diff(x)
            // array([ 1,  2,  3, -7])
            // >>> np.diff(x, n=2)
            // array([  1,   1, -10])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([1, 2, 4, 7, 0]);
            given=  np.diff(x);
            expected=
                "array([ 1,  2,  3, -7])";
            Assert.AreEqual(expected, given.repr);
            given=  np.diff(x, n=2);
            expected=
                "array([  1,   1, -10])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
            // >>> np.diff(x)
            // array([[2, 3, 4],
            //        [5, 1, 2]])
            // >>> np.diff(x, axis=0)
            // array([[-1,  2,  0, -2]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]]);
            given=  np.diff(x);
            expected=
                "array([[2, 3, 4],\n" +
                "       [5, 1, 2]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.diff(x, axis=0);
            expected=
                "array([[-1,  2,  0, -2]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
            // >>> np.diff(x)
            // array([1, 1], dtype='timedelta64[D]')
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64);
            given=  np.diff(x);
            expected=
                "array([1, 1], dtype='timedelta64[D]')";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void ediff1dTest()
        {
            // >>> x = np.array([1, 2, 4, 7, 0])
            // >>> np.ediff1d(x)
            // array([ 1,  2,  3, -7])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([1, 2, 4, 7, 0]);
            given=  np.ediff1d(x);
            expected=
                "array([ 1,  2,  3, -7])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
            // array([-99,   1,   2,   3,  -7,  88,  99])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]));
            expected=
                "array([-99,   1,   2,   3,  -7,  88,  99])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The returned array is always 1D.
            
            // >>> y = [[1, 2, 4], [1, 6, 24]]
            // >>> np.ediff1d(y)
            // array([ 1,  2, -3,  5, 18])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  y = [[1, 2, 4], [1, 6, 24]];
            given=  np.ediff1d(y);
            expected=
                "array([ 1,  2, -3,  5, 18])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void gradientTest()
        {
            // >>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
            // >>> np.gradient(f)
            // array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
            // >>> np.gradient(f, 2)
            // array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  f = np.array([1, 2, 4, 7, 11, 16], dtype=float);
            given=  np.gradient(f);
            expected=
                "array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])";
            Assert.AreEqual(expected, given.repr);
            given=  np.gradient(f, 2);
            expected=
                "array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Spacing can be also specified with an array that represents the coordinates
            // of the values F along the dimensions.
            // For instance a uniform spacing:
            
            // >>> x = np.arange(f.size)
            // >>> np.gradient(f, x)
            // array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.arange(f.size);
            given=  np.gradient(f, x);
            expected=
                "array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Or a non uniform one:
            
            // >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
            // >>> np.gradient(f, x)
            // array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float);
            given=  np.gradient(f, x);
            expected=
                "array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // For two dimensional arrays, the return will be two arrays ordered by
            // axis. In this example the first array stands for the gradient in
            // rows and the second one in columns direction:
            
            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
            // [array([[ 2.,  2., -1.],
            //         [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],
            //         [ 1. ,  1. ,  1. ]])]
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float));
            expected=
                "[array([[ 2.,  2., -1.],\n" +
                "        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],\n" +
                "        [ 1. ,  1. ,  1. ]])]";
            Assert.AreEqual(expected, given.repr);
            #endif
            // In this example the spacing is also specified:
            // uniform for axis=0 and non uniform for axis=1
            
            // >>> dx = 2.
            // >>> y = [1., 1.5, 3.5]
            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
            // [array([[ 1. ,  1. , -0.5],
            //         [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],
            //         [ 2. ,  1.7,  0.5]])]
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  dx = 2.;
            given=  y = [1., 1.5, 3.5];
            given=  np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y);
            expected=
                "[array([[ 1. ,  1. , -0.5],\n" +
                "        [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],\n" +
                "        [ 2. ,  1.7,  0.5]])]";
            Assert.AreEqual(expected, given.repr);
            #endif
            // It is possible to specify how boundaries are treated using edge_order
            
            // >>> x = np.array([0, 1, 2, 3, 4])
            // >>> f = x**2
            // >>> np.gradient(f, edge_order=1)
            // array([ 1.,  2.,  4.,  6.,  7.])
            // >>> np.gradient(f, edge_order=2)
            // array([-0.,  2.,  4.,  6.,  8.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([0, 1, 2, 3, 4]);
            given=  f = x**2;
            given=  np.gradient(f, edge_order=1);
            expected=
                "array([ 1.,  2.,  4.,  6.,  7.])";
            Assert.AreEqual(expected, given.repr);
            given=  np.gradient(f, edge_order=2);
            expected=
                "array([-0.,  2.,  4.,  6.,  8.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The axis keyword can be used to specify a subset of axes of which the
            // gradient is calculated
            
            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
            // array([[ 2.,  2., -1.],
            //        [ 2.,  2., -1.]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0);
            expected=
                "array([[ 2.,  2., -1.],\n" +
                "       [ 2.,  2., -1.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void crossTest()
        {
            // Vector cross-product.
            
            // >>> x = [1, 2, 3]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([-3,  6, -3])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [1, 2, 3];
            given=  y = [4, 5, 6];
            given=  np.cross(x, y);
            expected=
                "array([-3,  6, -3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // One vector with dimension 2.
            
            // >>> x = [1, 2]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([12, -6, -3])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [1, 2];
            given=  y = [4, 5, 6];
            given=  np.cross(x, y);
            expected=
                "array([12, -6, -3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Equivalently:
            
            // >>> x = [1, 2, 0]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([12, -6, -3])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [1, 2, 0];
            given=  y = [4, 5, 6];
            given=  np.cross(x, y);
            expected=
                "array([12, -6, -3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Both vectors with dimension 2.
            
            // >>> x = [1,2]
            // >>> y = [4,5]
            // >>> np.cross(x, y)
            // -3
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [1,2];
            given=  y = [4,5];
            given=  np.cross(x, y);
            expected=
                "-3";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Multiple vector cross-products. Note that the direction of the cross
            // product vector is defined by the right-hand rule.
            
            // >>> x = np.array([[1,2,3], [4,5,6]])
            // >>> y = np.array([[4,5,6], [1,2,3]])
            // >>> np.cross(x, y)
            // array([[-3,  6, -3],
            //        [ 3, -6,  3]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([[1,2,3], [4,5,6]]);
            given=  y = np.array([[4,5,6], [1,2,3]]);
            given=  np.cross(x, y);
            expected=
                "array([[-3,  6, -3],\n" +
                "       [ 3, -6,  3]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The orientation of c can be changed using the axisc keyword.
            
            // >>> np.cross(x, y, axisc=0)
            // array([[-3,  3],
            //        [ 6, -6],
            //        [-3,  3]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.cross(x, y, axisc=0);
            expected=
                "array([[-3,  3],\n" +
                "       [ 6, -6],\n" +
                "       [-3,  3]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Change the vector definition of x and y using axisa and axisb.
            
            // >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
            // >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
            // >>> np.cross(x, y)
            // array([[ -6,  12,  -6],
            //        [  0,   0,   0],
            //        [  6, -12,   6]])
            // >>> np.cross(x, y, axisa=0, axisb=0)
            // array([[-24,  48, -24],
            //        [-30,  60, -30],
            //        [-36,  72, -36]])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.array([[1,2,3], [4,5,6], [7, 8, 9]]);
            given=  y = np.array([[7, 8, 9], [4,5,6], [1,2,3]]);
            given=  np.cross(x, y);
            expected=
                "array([[ -6,  12,  -6],\n" +
                "       [  0,   0,   0],\n" +
                "       [  6, -12,   6]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.cross(x, y, axisa=0, axisb=0);
            expected=
                "array([[-24,  48, -24],\n" +
                "       [-30,  60, -30],\n" +
                "       [-36,  72, -36]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void trapzTest()
        {
            // >>> np.trapz([1,2,3])
            // 4.0
            // >>> np.trapz([1,2,3], x=[4,6,8])
            // 8.0
            // >>> np.trapz([1,2,3], dx=2)
            // 8.0
            // >>> a = np.arange(6).reshape(2, 3)
            // >>> a
            // array([[0, 1, 2],
            //        [3, 4, 5]])
            // >>> np.trapz(a, axis=0)
            // array([ 1.5,  2.5,  3.5])
            // >>> np.trapz(a, axis=1)
            // array([ 2.,  8.])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.trapz([1,2,3]);
            expected=
                "4.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.trapz([1,2,3], x=[4,6,8]);
            expected=
                "8.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.trapz([1,2,3], dx=2);
            expected=
                "8.0";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.arange(6).reshape(2, 3);
            given=  a;
            expected=
                "array([[0, 1, 2],\n" +
                "       [3, 4, 5]])";
            Assert.AreEqual(expected, given.repr);
            given=  np.trapz(a, axis=0);
            expected=
                "array([ 1.5,  2.5,  3.5])";
            Assert.AreEqual(expected, given.repr);
            given=  np.trapz(a, axis=1);
            expected=
                "array([ 2.,  8.])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void sincTest()
        {
            // >>> import matplotlib.pyplot as plt
            // >>> x = np.linspace(-4, 4, 41)
            // >>> np.sinc(x)
            // array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
            //         -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
            //          6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
            //          8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
            //         -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
            //          3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
            //          7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
            //          9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
            //          2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
            //         -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
            //         -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
            //          1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
            //         -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
            //         -4.92362781e-02,  -3.89804309e-17])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  import matplotlib.pyplot as plt;
            given=  x = np.linspace(-4, 4, 41);
            given=  np.sinc(x);
            expected=
                "array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n" +
                "        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n" +
                "         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n" +
                "         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n" +
                "        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n" +
                "         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n" +
                "         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n" +
                "         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n" +
                "         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n" +
                "        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n" +
                "        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n" +
                "         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n" +
                "        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n" +
                "        -4.92362781e-02,  -3.89804309e-17])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> plt.plot(x, np.sinc(x))
            // [<matplotlib.lines.Line2D object at 0x...>]
            // >>> plt.title("Sinc Function")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.ylabel("Amplitude")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.xlabel("X")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.show()
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  plt.plot(x, np.sinc(x));
            expected=
                "[<matplotlib.lines.Line2D object at 0x...>]";
            Assert.AreEqual(expected, given.repr);
            given=  plt.title("Sinc Function");
            expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
            given=  plt.ylabel("Amplitude");
            expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
            given=  plt.xlabel("X");
            expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
            given=  plt.show();
            #endif
            // It works in 2-D as well:
            
            // >>> x = np.linspace(-4, 4, 401)
            // >>> xx = np.outer(x, x)
            // >>> plt.imshow(np.sinc(xx))
            // <matplotlib.image.AxesImage object at 0x...>
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.linspace(-4, 4, 401);
            given=  xx = np.outer(x, x);
            given=  plt.imshow(np.sinc(xx));
            expected=
                "<matplotlib.image.AxesImage object at 0x...>";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void angleTest()
        {
            // >>> np.angle([1.0, 1.0j, 1+1j])               # in radians
            // array([ 0.        ,  1.57079633,  0.78539816])
            // >>> np.angle(1+1j, deg=True)                  # in degrees
            // 45.0
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.angle([1.0, 1.0j, 1+1j])               # in radians;
            expected=
                "array([ 0.        ,  1.57079633,  0.78539816])";
            Assert.AreEqual(expected, given.repr);
            given=  np.angle(1+1j, deg=True)                  # in degrees;
            expected=
                "45.0";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void realTest()
        {
            // >>> a = np.array([1+2j, 3+4j, 5+6j])
            // >>> a.real
            // array([ 1.,  3.,  5.])
            // >>> a.real = 9
            // >>> a
            // array([ 9.+2.j,  9.+4.j,  9.+6.j])
            // >>> a.real = np.array([9, 8, 7])
            // >>> a
            // array([ 9.+2.j,  8.+4.j,  7.+6.j])
            // >>> np.real(1 + 1j)
            // 1.0
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  a = np.array([1+2j, 3+4j, 5+6j]);
            given=  a.real;
            expected=
                "array([ 1.,  3.,  5.])";
            Assert.AreEqual(expected, given.repr);
            given=  a.real = 9;
            given=  a;
            expected=
                "array([ 9.+2.j,  9.+4.j,  9.+6.j])";
            Assert.AreEqual(expected, given.repr);
            given=  a.real = np.array([9, 8, 7]);
            given=  a;
            expected=
                "array([ 9.+2.j,  8.+4.j,  7.+6.j])";
            Assert.AreEqual(expected, given.repr);
            given=  np.real(1 + 1j);
            expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void imagTest()
        {
            // >>> a = np.array([1+2j, 3+4j, 5+6j])
            // >>> a.imag
            // array([ 2.,  4.,  6.])
            // >>> a.imag = np.array([8, 10, 12])
            // >>> a
            // array([ 1. +8.j,  3.+10.j,  5.+12.j])
            // >>> np.imag(1 + 1j)
            // 1.0
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  a = np.array([1+2j, 3+4j, 5+6j]);
            given=  a.imag;
            expected=
                "array([ 2.,  4.,  6.])";
            Assert.AreEqual(expected, given.repr);
            given=  a.imag = np.array([8, 10, 12]);
            given=  a;
            expected=
                "array([ 1. +8.j,  3.+10.j,  5.+12.j])";
            Assert.AreEqual(expected, given.repr);
            given=  np.imag(1 + 1j);
            expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void convolveTest()
        {
            // Note how the convolution operator flips the second array
            // before “sliding” the two across one another:
            
            // >>> np.convolve([1, 2, 3], [0, 1, 0.5])
            // array([ 0. ,  1. ,  2.5,  4. ,  1.5])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.convolve([1, 2, 3], [0, 1, 0.5]);
            expected=
                "array([ 0. ,  1. ,  2.5,  4. ,  1.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Only return the middle values of the convolution.
            // Contains boundary effects, where zeros are taken
            // into account:
            
            // >>> np.convolve([1,2,3],[0,1,0.5], 'same')
            // array([ 1. ,  2.5,  4. ])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.convolve([1,2,3],[0,1,0.5], 'same');
            expected=
                "array([ 1. ,  2.5,  4. ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The two arrays are of the same length, so there
            // is only one position where they completely overlap:
            
            // >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
            // array([ 2.5])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.convolve([1,2,3],[0,1,0.5], 'valid');
            expected=
                "array([ 2.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void clipTest()
        {
            // >>> a = np.arange(10)
            // >>> np.clip(a, 1, 8)
            // array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> np.clip(a, 3, 6, out=a)
            // array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
            // >>> a = np.arange(10)
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
            // array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  a = np.arange(10);
            given=  np.clip(a, 1, 8);
            expected=
                "array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])";
            Assert.AreEqual(expected, given.repr);
            given=  a;
            expected=
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
            given=  np.clip(a, 3, 6, out=a);
            expected=
                "array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])";
            Assert.AreEqual(expected, given.repr);
            given=  a = np.arange(10);
            given=  a;
            expected=
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
            given=  np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8);
            expected=
                "array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void nan_to_numTest()
        {
            // >>> np.nan_to_num(np.inf)
            // 1.7976931348623157e+308
            // >>> np.nan_to_num(-np.inf)
            // -1.7976931348623157e+308
            // >>> np.nan_to_num(np.nan)
            // 0.0
            // >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
            // >>> np.nan_to_num(x)
            // array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
            //         -1.28000000e+002,   1.28000000e+002])
            // >>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
            // >>> np.nan_to_num(y)
            // array([  1.79769313e+308 +0.00000000e+000j,
            //          0.00000000e+000 +0.00000000e+000j,
            //          0.00000000e+000 +1.79769313e+308j])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.nan_to_num(np.inf);
            expected=
                "1.7976931348623157e+308";
            Assert.AreEqual(expected, given.repr);
            given=  np.nan_to_num(-np.inf);
            expected=
                "-1.7976931348623157e+308";
            Assert.AreEqual(expected, given.repr);
            given=  np.nan_to_num(np.nan);
            expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
            given=  x = np.array([np.inf, -np.inf, np.nan, -128, 128]);
            given=  np.nan_to_num(x);
            expected=
                "array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n" +
                "        -1.28000000e+002,   1.28000000e+002])";
            Assert.AreEqual(expected, given.repr);
            given=  y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)]);
            given=  np.nan_to_num(y);
            expected=
                "array([  1.79769313e+308 +0.00000000e+000j,\n" +
                "         0.00000000e+000 +0.00000000e+000j,\n" +
                "         0.00000000e+000 +1.79769313e+308j])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void real_if_closeTest()
        {
            // >>> np.finfo(float).eps
            // 2.2204460492503131e-16
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.finfo(float).eps;
            expected=
                "2.2204460492503131e-16";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.real_if_close([2.1 + 4e-14j], tol=1000)
            // array([ 2.1])
            // >>> np.real_if_close([2.1 + 4e-13j], tol=1000)
            // array([ 2.1 +4.00000000e-13j])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  np.real_if_close([2.1 + 4e-14j], tol=1000);
            expected=
                "array([ 2.1])";
            Assert.AreEqual(expected, given.repr);
            given=  np.real_if_close([2.1 + 4e-13j], tol=1000);
            expected=
                "array([ 2.1 +4.00000000e-13j])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        [TestMethod]
        public void interpTest()
        {
            // >>> xp = [1, 2, 3]
            // >>> fp = [3, 2, 0]
            // >>> np.interp(2.5, xp, fp)
            // 1.0
            // >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
            // array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])
            // >>> UNDEF = -99.0
            // >>> np.interp(3.14, xp, fp, right=UNDEF)
            // -99.0
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  xp = [1, 2, 3];
            given=  fp = [3, 2, 0];
            given=  np.interp(2.5, xp, fp);
            expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            given=  np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp);
            expected=
                "array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])";
            Assert.AreEqual(expected, given.repr);
            given=  UNDEF = -99.0;
            given=  np.interp(3.14, xp, fp, right=UNDEF);
            expected=
                "-99.0";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Plot an interpolant to the sine function:
            
            // >>> x = np.linspace(0, 2*np.pi, 10)
            // >>> y = np.sin(x)
            // >>> xvals = np.linspace(0, 2*np.pi, 50)
            // >>> yinterp = np.interp(xvals, x, y)
            // >>> import matplotlib.pyplot as plt
            // >>> plt.plot(x, y, 'o')
            // [<matplotlib.lines.Line2D object at 0x...>]
            // >>> plt.plot(xvals, yinterp, '-x')
            // [<matplotlib.lines.Line2D object at 0x...>]
            // >>> plt.show()
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = np.linspace(0, 2*np.pi, 10);
            given=  y = np.sin(x);
            given=  xvals = np.linspace(0, 2*np.pi, 50);
            given=  yinterp = np.interp(xvals, x, y);
            given=  import matplotlib.pyplot as plt;
            given=  plt.plot(x, y, 'o');
            expected=
                "[<matplotlib.lines.Line2D object at 0x...>]";
            Assert.AreEqual(expected, given.repr);
            given=  plt.plot(xvals, yinterp, '-x');
            expected=
                "[<matplotlib.lines.Line2D object at 0x...>]";
            Assert.AreEqual(expected, given.repr);
            given=  plt.show();
            #endif
            // Interpolation with periodic x-coordinates:
            
            // >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
            // >>> xp = [190, -190, 350, -350]
            // >>> fp = [5, 10, 3, 4]
            // >>> np.interp(x, xp, fp, period=360)
            // array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [-180, -170, -185, 185, -10, -5, 0, 365];
            given=  xp = [190, -190, 350, -350];
            given=  fp = [5, 10, 3, 4];
            given=  np.interp(x, xp, fp, period=360);
            expected=
                "array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Complex interpolation:
            
            // >>> x = [1.5, 4.0]
            // >>> xp = [2,3,5]
            // >>> fp = [1.0j, 0, 2+3j]
            // >>> np.interp(x, xp, fp)
            // array([ 0.+1.j ,  1.+1.5j])
            // 
            
            #if TODO
            object given = null;
            object expected = null;
            given=  x = [1.5, 4.0];
            given=  xp = [2,3,5];
            given=  fp = [1.0j, 0, 2+3j];
            given=  np.interp(x, xp, fp);
            expected=
                "array([ 0.+1.j ,  1.+1.5j])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
    }
}
