// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_bitwiseTest : BaseTestCase
    {
        
        [TestMethod]
        public void bitwise_andTest()
        {
            // The number 13 is represented by 00001101.  Likewise, 17 is
            // represented by 00010001.  The bit-wise AND of 13 and 17 is
            // therefore 000000001, or 1:
            
            // >>> np.bitwise_and(13, 17)
            // 1
            // 
            
            #if TODO
            var given=  np.bitwise_and(13, 17);
            var expected=
                "1";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_and(14, 13)
            // 12
            // >>> np.binary_repr(12)
            // '1100'
            // >>> np.bitwise_and([14,3], 13)
            // array([12,  1])
            // 
            
            #if TODO
             given=  np.bitwise_and(14, 13);
             expected=
                "12";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(12);
             expected=
                "'1100'";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_and({14,3}, 13);
             expected=
                "array([12,  1])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_and([11,7], [4,25])
            // array([0, 1])
            // >>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
            // array([ 2,  4, 16])
            // >>> np.bitwise_and([True, True], [False, True])
            // array([False,  True])
            // 
            
            #if TODO
             given=  np.bitwise_and({11,7}, {4,25});
             expected=
                "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_and(np.array({2,5,255}), np.array({3,14,16}));
             expected=
                "array([ 2,  4, 16])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_and({True, True}, {False, True});
             expected=
                "array([False,  True])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void bitwise_orTest()
        {
            // The number 13 has the binaray representation 00001101. Likewise,
            // 16 is represented by 00010000.  The bit-wise OR of 13 and 16 is
            // then 000111011, or 29:
            
            // >>> np.bitwise_or(13, 16)
            // 29
            // >>> np.binary_repr(29)
            // '11101'
            // 
            
            #if TODO
            var given=  np.bitwise_or(13, 16);
            var expected=
                "29";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(29);
             expected=
                "'11101'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_or(32, 2)
            // 34
            // >>> np.bitwise_or([33, 4], 1)
            // array([33,  5])
            // >>> np.bitwise_or([33, 4], [1, 2])
            // array([33,  6])
            // 
            
            #if TODO
             given=  np.bitwise_or(32, 2);
             expected=
                "34";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_or({33, 4}, 1);
             expected=
                "array([33,  5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_or({33, 4}, {1, 2});
             expected=
                "array([33,  6])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
            // array([  6,   5, 255])
            // >>> np.array([2, 5, 255]) | np.array([4, 4, 4])
            // array([  6,   5, 255])
            // >>> np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),
            // ...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))
            // array([         6,          5,        255, 2147483647])
            // >>> np.bitwise_or([True, True], [False, True])
            // array([ True,  True])
            // 
            
            #if TODO
             given=  np.bitwise_or(np.array({2, 5, 255}), np.array({4, 4, 4}));
             expected=
                "array([  6,   5, 255])";
            Assert.AreEqual(expected, given.repr);
             given=  np.array({2, 5, 255}) | np.array({4, 4, 4});
             expected=
                "array([  6,   5, 255])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_or(np.array({2, 5, 255, 2147483647L}, dtype=np.int32),;
             expected=
                "...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))\n" +
                "array([         6,          5,        255, 2147483647])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_or({True, True}, {False, True});
             expected=
                "array([ True,  True])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void bitwise_xorTest()
        {
            // The number 13 is represented by 00001101. Likewise, 17 is
            // represented by 00010001.  The bit-wise XOR of 13 and 17 is
            // therefore 00011100, or 28:
            
            // >>> np.bitwise_xor(13, 17)
            // 28
            // >>> np.binary_repr(28)
            // '11100'
            // 
            
            #if TODO
            var given=  np.bitwise_xor(13, 17);
            var expected=
                "28";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(28);
             expected=
                "'11100'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_xor(31, 5)
            // 26
            // >>> np.bitwise_xor([31,3], 5)
            // array([26,  6])
            // 
            
            #if TODO
             given=  np.bitwise_xor(31, 5);
             expected=
                "26";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_xor({31,3}, 5);
             expected=
                "array([26,  6])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.bitwise_xor([31,3], [5,6])
            // array([26,  5])
            // >>> np.bitwise_xor([True, True], [False, True])
            // array([ True, False])
            // 
            
            #if TODO
             given=  np.bitwise_xor({31,3}, {5,6});
             expected=
                "array([26,  5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bitwise_xor({True, True}, {False, True});
             expected=
                "array([ True, False])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void invertTest()
        {
            // We’ve seen that 13 is represented by 00001101.
            // The invert or bit-wise NOT of 13 is then:
            
            // >>> np.invert(np.array([13], dtype=uint8))
            // array([242], dtype=uint8)
            // >>> np.binary_repr(x, width=8)
            // '00001101'
            // >>> np.binary_repr(242, width=8)
            // '11110010'
            // 
            
            #if TODO
            var given=  np.invert(np.array({13}, dtype=uint8));
            var expected=
                "array([242], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(x, width=8);
             expected=
                "'00001101'";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(242, width=8);
             expected=
                "'11110010'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The result depends on the bit-width:
            
            // >>> np.invert(np.array([13], dtype=uint16))
            // array([65522], dtype=uint16)
            // >>> np.binary_repr(x, width=16)
            // '0000000000001101'
            // >>> np.binary_repr(65522, width=16)
            // '1111111111110010'
            // 
            
            #if TODO
             given=  np.invert(np.array({13}, dtype=uint16));
             expected=
                "array([65522], dtype=uint16)";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(x, width=16);
             expected=
                "'0000000000001101'";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(65522, width=16);
             expected=
                "'1111111111110010'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // When using signed integer types the result is the two’s complement of
            // the result for the unsigned type:
            
            // >>> np.invert(np.array([13], dtype=int8))
            // array([-14], dtype=int8)
            // >>> np.binary_repr(-14, width=8)
            // '11110010'
            // 
            
            #if TODO
             given=  np.invert(np.array({13}, dtype=int8));
             expected=
                "array([-14], dtype=int8)";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(-14, width=8);
             expected=
                "'11110010'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Booleans are accepted as well:
            
            // >>> np.invert(array([True, False]))
            // array([False,  True])
            // 
            
            #if TODO
             given=  np.invert(array({True, False}));
             expected=
                "array([False,  True])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void left_shiftTest()
        {
            // >>> np.binary_repr(5)
            // '101'
            // >>> np.left_shift(5, 2)
            // 20
            // >>> np.binary_repr(20)
            // '10100'
            // 
            
            #if TODO
            var given=  np.binary_repr(5);
            var expected=
                "'101'";
            Assert.AreEqual(expected, given.repr);
             given=  np.left_shift(5, 2);
             expected=
                "20";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(20);
             expected=
                "'10100'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.left_shift(5, [1,2,3])
            // array([10, 20, 40])
            // 
            
            #if TODO
             given=  np.left_shift(5, {1,2,3});
             expected=
                "array([10, 20, 40])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void right_shiftTest()
        {
            // >>> np.binary_repr(10)
            // '1010'
            // >>> np.right_shift(10, 1)
            // 5
            // >>> np.binary_repr(5)
            // '101'
            // 
            
            #if TODO
            var given=  np.binary_repr(10);
            var expected=
                "'1010'";
            Assert.AreEqual(expected, given.repr);
             given=  np.right_shift(10, 1);
             expected=
                "5";
            Assert.AreEqual(expected, given.repr);
             given=  np.binary_repr(5);
             expected=
                "'101'";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.right_shift(10, [1,2,3])
            // array([5, 2, 1])
            // 
            
            #if TODO
             given=  np.right_shift(10, {1,2,3});
             expected=
                "array([5, 2, 1])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }


        [TestMethod]
        public void packbitsTest()
        {
            // >>> a = np.array([[[1,0,1],
            // ...                [0,1,0]],
            // ...               [[1,1,0],
            // ...                [0,0,1]]])
            // >>> b = np.packbits(a, axis=-1)
            // >>> b
            // array([[[160],[64]],[[192],[32]]], dtype=uint8)
            // 

            var a = np.array(new[, ,] {{{1,0,1},
                                                { 0,1,0}},
                                                {{1,1,0},
                                                { 0,0,1}}});
            var b = np.packbits(a, axis: -1);
            var given = b;
            var expected =
                "array([[[160],\n        [ 64]],\n\n       [[192],\n        [ 32]]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
            // Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
            // and 32 = 0010 0000.            
        }

        [TestMethod]
        public void unpackbitsTest()
        {
            // >>> a = np.array([[2], [7], [23]], dtype=np.uint8)
            // >>> a
            // array([[ 2],
            //        [ 7],
            //        [23]], dtype=uint8)
            // >>> b = np.unpackbits(a, axis=1)
            // >>> b
            // array([[0, 0, 0, 0, 0, 0, 1, 0],
            //        [0, 0, 0, 0, 0, 1, 1, 1],
            //        [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
            // 

            NDarray a = np.array(new[,] { { (byte)2 }, { (byte)7 }, { (byte)23 } }, dtype: np.uint8);
            var given = a;
            var expected =
                "array([[ 2],\n" +
                "       [ 7],\n" +
                "       [23]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
            var b = np.unpackbits(a, axis: 1);
            given = b;
            expected =
                "array([[0, 0, 0, 0, 0, 0, 1, 0],\n" +
                "       [0, 0, 0, 0, 0, 1, 1, 1],\n" +
                "       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)";
            Assert.AreEqual(expected, given.repr);
        }

        [TestMethod]
        public void binary_reprTest()
        {
            // >>> np.binary_repr(3)
            // '11'
            // >>> np.binary_repr(-3)
            // '-11'
            // >>> np.binary_repr(3, width=4)
            // '0011'
            // 

            var given = np.binary_repr(3);
            var expected =
                "11";
            Assert.AreEqual(expected, given);
            given = np.binary_repr(-3);
            expected =
                "-11";
            Assert.AreEqual(expected, given);
            given = np.binary_repr(3, width: 4);
            expected =
                "0011";
            Assert.AreEqual(expected, given);

            // The two’s complement is returned when the input number is negative and
            // width is specified:

            // >>> np.binary_repr(-3, width=3)
            // '101'
            // >>> np.binary_repr(-3, width=5)
            // '11101'
            // 

            given = np.binary_repr(-3, width: 3);
            expected =
                "101";
            Assert.AreEqual(expected, given);
            given = np.binary_repr(-3, width: 5);
            expected =
                "11101";
            Assert.AreEqual(expected, given);
        }

    }
}
